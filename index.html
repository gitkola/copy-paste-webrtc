<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P2P WebRTC</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #0a0a0a;
        color: #fff;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .container {
        max-width: 700px;
        width: 100%;
        text-align: center;
      }

      .videos {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }

      video {
        width: 100%;
        height: 240px;
        background: #1a1a1a;
        border-radius: 12px;
        object-fit: cover;
        border: 2px solid transparent;
      }

      video.active {
        border-color: #00ff88;
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      }

      .placeholder {
        width: 100%;
        height: 240px;
        background: #1a1a1a;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        font-size: 16px;
        border: 2px dashed #333;
      }

      .status {
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 25px;
        font-size: 18px;
        font-weight: 500;
      }

      .share-box {
        background: linear-gradient(135deg, #2a2a2a, #1a3a2a);
        border-radius: 12px;
        padding: 30px;
        margin: 25px 0;
        border: 1px solid #333;
      }

      .share-link {
        background: #0a0a0a;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 15px;
        width: 100%;
        color: #fff;
        font-size: 13px;
        margin: 15px 0;
        word-break: break-all;
        font-family: 'SF Mono', Monaco, monospace;
        max-height: 120px;
        overflow-y: auto;
      }

      .code-input {
        background: #0a0a0a;
        border: 2px solid #444;
        border-radius: 8px;
        padding: 15px;
        width: 100%;
        color: #fff;
        font-size: 13px;
        margin: 15px 0;
        font-family: 'SF Mono', Monaco, monospace;
        min-height: 100px;
        resize: vertical;
      }

      .code-input:focus {
        outline: none;
        border-color: #00ff88;
      }

      .btn {
        padding: 12px 24px;
        background: linear-gradient(135deg, #00ff88, #00cc66);
        color: #000;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 600;
        transition: all 0.2s;
        margin: 10px;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
      }

      .btn.success {
        background: linear-gradient(135deg, #00cc66, #00aa44);
      }

      .timer {
        font-size: 16px;
        color: #ff6b6b;
        font-weight: 500;
        margin: 15px 0;
        opacity: 0.8;
      }

      .role {
        display: inline-block;
        padding: 6px 12px;
        background: rgba(0, 255, 136, 0.2);
        color: #00ff88;
        border-radius: 16px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        margin-bottom: 15px;
      }

      .hidden {
        display: none;
      }

      .stage-indicator {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
      }

      .stage {
        width: 8px;
        height: 8px;
        background: #333;
        border-radius: 50%;
        transition: all 0.3s;
      }

      .stage.active {
        background: #00ff88;
        transform: scale(1.5);
      }

      h3 {
        margin: 20px 0 10px;
        font-size: 16px;
        color: #aaa;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Initiator: Generate and wait -->
      <div id="initiatorState" class="hidden">
        <div class="role">Initiator</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage"></div>
          <div class="stage"></div>
        </div>
        <div class="status" id="initiatorStatus">Offer generated</div>

        <div class="share-box">
          <h3>1. Share this link:</h3>
          <textarea class="share-link" id="initiatorLink" readonly></textarea>
          <button class="btn" id="copyInitiatorBtn">üìã Copy Link</button>
          <div class="timer" id="initiatorTimer"></div>

          <h3>2. Paste answer code here:</h3>
          <textarea
            class="code-input"
            id="answerInput"
            placeholder="Waiting for answer code..."
          ></textarea>
          <button class="btn" id="connectBtn">Connect</button>
        </div>
      </div>

      <!-- Responder: Generate response code -->
      <div id="responderState" class="hidden">
        <div class="role">Responder</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage active"></div>
          <div class="stage"></div>
        </div>

        <div class="videos">
          <video
            id="responderVideo"
            autoplay
            muted
            playsinline
            class="active"
          ></video>
          <div class="placeholder">Waiting for connection...</div>
        </div>

        <div class="status" id="responderStatus">Answer generated</div>
        <div class="share-box">
          <h3>Copy this code and send back:</h3>
          <textarea class="share-link" id="responderCode" readonly></textarea>
          <button class="btn" id="copyResponderBtn">üìã Copy Code</button>
        </div>
      </div>

      <!-- Connecting state -->
      <div id="connectingState" class="hidden">
        <div class="role">Connecting</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage active"></div>
          <div class="stage active"></div>
        </div>

        <div class="videos">
          <video
            id="connectingLocalVideo"
            autoplay
            muted
            playsinline
            class="active"
          ></video>
          <div class="placeholder">Establishing connection...</div>
        </div>

        <div class="status" id="connectingStatus">‚è≥ Connecting...</div>
      </div>

      <!-- Connected -->
      <div id="connectedState" class="hidden">
        <div class="role">Connected</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage active"></div>
          <div class="stage active"></div>
        </div>

        <div class="videos">
          <video
            id="localVideo"
            autoplay
            muted
            playsinline
            class="active"
          ></video>
          <video id="remoteVideo" autoplay playsinline class="active"></video>
        </div>

        <div class="status">üéâ Video call connected!</div>
      </div>

      <!-- Initial -->
      <div id="initialState">
        <div class="status">Open a connection link to start</div>
      </div>
    </div>

    <script>
      class P2PWebRTC {
        constructor() {
          this.pc = null;
          this.dataChannel = null;
          this.mediaPc = null;
          this.localStream = null;
          this.role = null;
          this.timer = null;
          this.connectionEstablished = false;

          this.iceServers = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
          ];
        }

        async init() {
          if (location.hash) {
            await this.handleOffer();
          } else {
            await this.startAsInitiator();
          }
        }

        async startAsInitiator() {
          this.role = 'initiator';
          this.showState('initiatorState');

          await this.createDataConnection();
          await this.generateOffer();
          this.startTimer();
        }

        async createDataConnection() {
          this.pc = new RTCPeerConnection({
            iceServers: this.iceServers,
            iceCandidatePoolSize: 10,
          });

          this.pc.oniceconnectionstatechange = () => {
            console.log('ICE:', this.pc.iceConnectionState);
          };

          if (this.role === 'initiator') {
            this.dataChannel = this.pc.createDataChannel('media', {
              ordered: true,
            });
            this.setupDataChannel(this.dataChannel);
          }

          this.pc.ondatachannel = (event) => {
            this.dataChannel = event.channel;
            this.setupDataChannel(this.dataChannel);
          };

          this.pc.onconnectionstatechange = () => {
            console.log('PC:', this.pc.connectionState);
            if (
              this.pc.connectionState === 'connected' &&
              !this.connectionEstablished
            ) {
              this.connectionEstablished = true;
              setTimeout(() => this.startMediaNegotiation(), 500);
            }
          };
        }

        setupDataChannel(channel) {
          channel.onopen = () => {
            console.log('DataChannel opened');
            this.connectionEstablished = true;
          };

          channel.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'media-offer') {
              await this.handleMediaOffer(data);
            } else if (data.type === 'media-answer') {
              await this.handleMediaAnswer(data);
            }
          };
        }

        async generateOffer() {
          const offer = await this.pc.createOffer();
          await this.pc.setLocalDescription(offer);
          await this.waitForICE();

          const offerData = {
            type: 'offer',
            sdp: this.pc.localDescription.sdp,
          };

          const encoded = btoa(JSON.stringify(offerData));
          const url = `${window.location.origin}${window.location.pathname}#${encoded}`;

          document.getElementById('initiatorLink').value = url;
          this.updateStatus(
            'initiatorStatus',
            'üì§ Share link & wait for answer code'
          );
        }

        async handleOffer() {
          try {
            const data = JSON.parse(atob(location.hash.slice(1)));

            if (data.type !== 'offer') return;

            this.role = 'responder';
            this.showState('responderState');

            await this.setupCamera('responderVideo');
            await this.createDataConnection();

            await this.pc.setRemoteDescription({
              type: 'offer',
              sdp: data.sdp,
            });

            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);
            await this.waitForICE();

            const answerData = {
              type: 'answer',
              sdp: this.pc.localDescription.sdp,
            };

            const encoded = btoa(JSON.stringify(answerData));
            document.getElementById('responderCode').value = encoded;

            this.updateStatus(
              'responderStatus',
              'üì§ Copy code above and send it back'
            );
          } catch (err) {
            console.error('Handle offer error:', err);
            this.showState('initialState');
          }
        }

        async processAnswer() {
          const input = document.getElementById('answerInput').value.trim();
          if (!input) return;

          try {
            const data = JSON.parse(atob(input));

            if (data.type !== 'answer') {
              alert('Invalid answer code');
              return;
            }

            this.showState('connectingState');
            this.updateStatus(
              'connectingStatus',
              '‚è≥ Establishing connection...'
            );

            await this.setupCamera('connectingLocalVideo');

            await this.pc.setRemoteDescription({
              type: 'answer',
              sdp: data.sdp,
            });

            this.clearTimer();
          } catch (err) {
            console.error('Process answer error:', err);
            alert('Invalid answer code. Please check and try again.');
          }
        }

        async startMediaNegotiation() {
          console.log('Starting media negotiation, role:', this.role);

          if (this.role === 'initiator') {
            await this.sendMediaOffer();
          }
        }

        async setupCamera(videoId) {
          try {
            this.localStream = await navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 480 },
              audio: true,
            });

            const videoEl = document.getElementById(videoId);
            if (videoEl) {
              videoEl.srcObject = this.localStream;
            }
          } catch (err) {
            console.error('Camera error:', err);
          }
        }

        async sendMediaOffer() {
          this.mediaPc = new RTCPeerConnection({
            iceServers: this.iceServers,
            iceCandidatePoolSize: 10,
          });

          if (this.localStream) {
            this.localStream.getTracks().forEach((track) => {
              this.mediaPc.addTrack(track, this.localStream);
            });
          }

          this.mediaPc.ontrack = (event) => {
            this.showConnectedState(event.streams[0]);
          };

          const offer = await this.mediaPc.createOffer();
          await this.mediaPc.setLocalDescription(offer);
          await this.waitForICE(this.mediaPc);

          const mediaOffer = {
            type: 'media-offer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          this.dataChannel.send(JSON.stringify(mediaOffer));
        }

        async handleMediaOffer(data) {
          this.mediaPc = new RTCPeerConnection({
            iceServers: this.iceServers,
            iceCandidatePoolSize: 10,
          });

          if (this.localStream) {
            this.localStream.getTracks().forEach((track) => {
              this.mediaPc.addTrack(track, this.localStream);
            });
          }

          this.mediaPc.ontrack = (event) => {
            this.showConnectedState(event.streams[0]);
          };

          await this.mediaPc.setRemoteDescription({
            type: 'offer',
            sdp: data.sdp,
          });

          const answer = await this.mediaPc.createAnswer();
          await this.mediaPc.setLocalDescription(answer);
          await this.waitForICE(this.mediaPc);

          const mediaAnswer = {
            type: 'media-answer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          this.dataChannel.send(JSON.stringify(mediaAnswer));
        }

        async handleMediaAnswer(data) {
          await this.mediaPc.setRemoteDescription({
            type: 'answer',
            sdp: data.sdp,
          });
        }

        showConnectedState(remoteStream) {
          this.showState('connectedState');

          const localVideo = document.getElementById('localVideo');
          if (this.localStream) {
            localVideo.srcObject = this.localStream;
          }

          const remoteVideo = document.getElementById('remoteVideo');
          remoteVideo.srcObject = remoteStream;
        }

        waitForICE(pc = this.pc) {
          return new Promise((resolve) => {
            if (pc.iceGatheringState === 'complete') {
              resolve();
              return;
            }

            const onStateChange = () => {
              if (pc.iceGatheringState === 'complete') {
                pc.removeEventListener(
                  'icegatheringstatechange',
                  onStateChange
                );
                resolve();
              }
            };

            pc.addEventListener('icegatheringstatechange', onStateChange);
            setTimeout(resolve, 3000);
          });
        }

        showState(stateId) {
          document.querySelectorAll('.container > div').forEach((el) => {
            el.classList.add('hidden');
          });
          document.getElementById(stateId).classList.remove('hidden');
        }

        updateStatus(elementId, message) {
          const el = document.getElementById(elementId);
          if (el) el.textContent = message;
        }

        startTimer() {
          let remaining = 120;
          const timerEl = document.getElementById('initiatorTimer');

          const tick = () => {
            const min = Math.floor(remaining / 60);
            const sec = remaining % 60;
            timerEl.textContent = `Expires in ${min}:${sec
              .toString()
              .padStart(2, '0')}`;
            remaining--;

            if (remaining < 0) {
              this.clearTimer();
              timerEl.textContent = 'Expired';
            }
          };

          tick();
          this.timer = setInterval(tick, 1000);
        }

        clearTimer() {
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
        }
      }

      const rtc = new P2PWebRTC();

      window.addEventListener('load', () => rtc.init());

      document.getElementById('copyInitiatorBtn').onclick = function () {
        const link = document.getElementById('initiatorLink');
        navigator.clipboard.writeText(link.value);
        this.textContent = '‚úÖ Copied!';
        this.classList.add('success');
        setTimeout(() => {
          this.textContent = 'üìã Copy Link';
          this.classList.remove('success');
        }, 2000);
      };

      document.getElementById('copyResponderBtn').onclick = function () {
        const code = document.getElementById('responderCode');
        navigator.clipboard.writeText(code.value);
        this.textContent = '‚úÖ Copied!';
        this.classList.add('success');
        setTimeout(() => {
          this.textContent = 'üìã Copy Code';
          this.classList.remove('success');
        }, 2000);
      };

      document.getElementById('connectBtn').onclick = () => rtc.processAnswer();
    </script>
  </body>
</html>
