<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="format-detection" content="telephone=no" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <title>P2P WebRTC</title>
    <!-- QR Code Libraries -->
    <script type="text/javascript" src="qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://unpkg.com/@zxing/library@latest/umd/index.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        touch-action: none;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: fixed;
        -webkit-user-select: none;
        user-select: none;
        touch-action: none;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #0a0a0a;
        color: #fff;
      }

      button,
      .toggle-btn,
      .control-btn,
      textarea,
      input {
        touch-action: manipulation;
      }

      /* Video Grid View Layer - Bottom */
      #video-grid-view {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #0a0a0a;
        display: flex;
        overflow: hidden;
      }

      /* Default: Local video full screen (before connection) */
      #local-video {
        width: 100%;
        height: 100%;
        flex-shrink: 0;
      }

      #remote-video {
        width: 100%;
        height: 100%;
        flex-shrink: 0;
      }

      /* 50/50 Split Mode - vertical (portrait) */
      #video-grid-view.mode-split-v {
        flex-direction: column;
      }

      #video-grid-view.mode-split-v #local-video,
      #video-grid-view.mode-split-v #remote-video:not(.hidden) {
        width: 100%;
        height: 50%;
      }

      /* 50/50 Split Mode - horizontal (landscape) */
      #video-grid-view.mode-split-h {
        flex-direction: row;
      }

      #video-grid-view.mode-split-h #local-video,
      #video-grid-view.mode-split-h #remote-video:not(.hidden) {
        width: 50%;
        height: 100%;
      }

      /* Full-screen Mode */
      #video-grid-view.mode-full {
        position: relative;
      }

      #video-grid-view.mode-full video.full {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      #video-grid-view.mode-full video.thumbnail {
        width: 120px;
        height: 160px;
        position: absolute;
        bottom: 80px;
        right: 20px;
        z-index: 2;
        border-radius: 12px;
      }

      #video-grid-view.mode-full #local-video.thumbnail {
        border-color: #0088ff;
      }

      video {
        background: #1a1a1a;
        object-fit: cover;
        cursor: pointer;
        touch-action: none;
      }

      #local-video {
        transform: scaleX(-1);
        border: 3px solid #0088ff;
      }

      /* Disable pointer events on local video before connection */
      #local-video.no-click {
        pointer-events: none;
      }

      video.hidden {
        height: 0 !important;
        width: 0 !important;
        opacity: 0;
        pointer-events: none;
        position: absolute;
      }

      /* Controls Overlay Layer - Top */
      #controls-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 10;
      }

      .control-btn {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        padding: 14px 24px;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        touch-action: manipulation;
      }

      .control-btn:active {
        transform: scale(0.95);
        background: rgba(0, 0, 0, 0.9);
      }

      .control-btn.primary {
        background: linear-gradient(135deg, #00ff88, #00cc66);
        color: #000;
        border-color: transparent;
      }

      .control-btn:disabled,
      .control-btn.loading {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }

      .control-btn svg {
        width: 20px;
        height: 20px;
        margin-right: 8px;
        flex-shrink: 0;
      }

      .control-btn.loading::after {
        content: '';
        display: inline-block;
        width: 14px;
        height: 14px;
        margin-left: 8px;
        border: 2px solid currentColor;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 0.6s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #reload-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        pointer-events: auto;
        touch-action: manipulation;
      }

      #reload-btn svg {
        width: 24px;
        height: 24px;
      }

      #reload-btn:active {
        transform: scale(0.9);
        background: rgba(0, 0, 0, 0.9);
      }

      #top-button {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        transition: all 0.3s ease;
      }

      #top-button.close-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff4444, #cc0000);
        color: #fff;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        font-weight: 700;
        border: 2px solid rgba(255, 255, 255, 0.3);
        top: 20px;
        right: 20px;
        left: auto;
        transform: none;
      }

      #top-button.close-btn svg {
        width: 24px;
        height: 24px;
      }

      #bottom-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 20px;
        pointer-events: auto;
        transition: all 0.3s ease;
      }

      #bottom-controls.top-position {
        bottom: auto;
        top: 20px;
        left: 90px;
        transform: none;
      }

      .toggle-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        pointer-events: auto;
        touch-action: manipulation;
      }

      .toggle-btn svg {
        width: 24px;
        height: 24px;
        flex-shrink: 0;
      }

      .toggle-btn:active {
        transform: scale(0.9);
      }

      .toggle-btn.off {
        background: rgba(255, 0, 0, 0.3);
        border-color: rgba(255, 0, 0, 0.5);
      }

      /* Modal */
      #paste-modal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 400px;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 24px;
        z-index: 20;
        pointer-events: auto;
      }

      #paste-modal.hidden {
        display: none;
      }

      #paste-modal h3 {
        margin-bottom: 16px;
        font-size: 18px;
        color: #fff;
      }

      #answer-input {
        width: 100%;
        min-height: 120px;
        background: #1a1a1a;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 12px;
        color: #fff;
        font-size: 13px;
        font-family: 'SF Mono', Monaco, monospace;
        resize: vertical;
        margin-bottom: 16px;
      }

      #answer-input:focus {
        outline: none;
        border-color: #00ff88;
      }

      .modal-actions {
        display: flex;
        gap: 12px;
      }

      .modal-actions button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
      }

      #modal-connect {
        background: linear-gradient(135deg, #00ff88, #00cc66);
        color: #000;
      }

      #modal-cancel {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      /* Toast */
      #toast {
        position: absolute;
        bottom: 200px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 12px 24px;
        border-radius: 24px;
        font-size: 14px;
        z-index: 30;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }

      #toast.show {
        opacity: 1;
      }

      /* Landscape mode adjustments */
      @media (orientation: landscape) {
        #video-grid-view.mode-split-v {
          flex-direction: row;
        }

        #video-grid-view.mode-split-v #local-video,
        #video-grid-view.mode-split-v #remote-video:not(.hidden) {
          width: 50%;
          height: 100%;
        }

        #video-grid-view.mode-full video.thumbnail {
          width: 160px;
          height: 120px;
        }
      }

      .hidden {
        display: none !important;
      }

      #paste-modal.hidden {
        display: none !important;
      }

      /* QR Code Modal */
      #qr-modal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 24px;
        padding: 30px;
        z-index: 25;
        pointer-events: auto;
        max-width: 90%;
        max-height: 90%;
        overflow: auto;
      }

      #qr-modal.hidden {
        display: none !important;
      }

      #qr-paste-modal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 24px;
        padding: 30px;
        z-index: 25;
        pointer-events: auto;
        max-width: 90%;
        width: 500px;
      }

      #qr-paste-modal.hidden {
        display: none !important;
      }

      #qr-paste-modal h3 {
        color: #fff;
        margin-bottom: 20px;
        font-size: 20px;
        text-align: center;
      }

      #qr-modal h3 {
        color: #fff;
        margin-bottom: 20px;
        font-size: 20px;
        text-align: center;
      }

      #qr-display {
        background: white;
        padding: 20px;
        border-radius: 12px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 20px;
      }

      #qr-display canvas {
        max-width: 100%;
        height: auto;
      }

      .qr-actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .qr-actions button {
        flex: 1;
        min-width: 120px;
        padding: 14px 24px;
        border: none;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }

      .qr-actions button:active {
        transform: scale(0.95);
      }

      #qr-share {
        background: linear-gradient(135deg, #00ff88, #00cc66);
        color: #000;
      }

      #qr-download {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      #qr-close {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      /* QR Paste Area */
      #qr-paste-area {
        margin-top: 20px;
        padding: 20px;
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        text-align: center;
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
      }

      #qr-paste-area.dragover {
        border-color: #00ff88;
        background: rgba(0, 255, 136, 0.1);
      }

      #qr-file-input {
        display: none;
      }

      .button-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .secondary-btn {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        padding: 10px 18px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        touch-action: manipulation;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .secondary-btn:active {
        transform: scale(0.95);
        background: rgba(0, 0, 0, 0.9);
      }

      .secondary-btn svg {
        width: 16px;
        height: 16px;
      }

      #button-group-container {
        position: absolute;
        top: 90px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <!-- Video Grid View Layer -->
    <div id="video-grid-view">
      <video
        id="local-video"
        autoplay
        muted
        playsinline
        class="no-click"
      ></video>
      <video id="remote-video" autoplay playsinline class="hidden"></video>
    </div>

    <!-- Controls Overlay Layer -->
    <div id="controls-overlay">
      <button id="reload-btn" class="toggle-btn"></button>

      <button id="top-button" class="control-btn primary"></button>

      <!-- QR Code Buttons -->
      <div id="button-group-container">
        <button id="qr-show-btn" class="secondary-btn hidden">Show QR</button>
        <button id="qr-paste-btn" class="secondary-btn hidden">
          Paste QR Answer
        </button>
      </div>

      <!-- Initial QR Paste Button (for scanning offer QR codes) -->
      <button
        id="initial-qr-paste-btn"
        class="control-btn"
        style="
          position: absolute;
          bottom: 100px;
          left: 50%;
          transform: translateX(-50%);
        "
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <rect x="3" y="3" width="7" height="7" />
          <rect x="14" y="3" width="7" height="7" />
          <rect x="14" y="14" width="7" height="7" />
          <rect x="3" y="14" width="7" height="7" />
        </svg>
        <span>Paste QR Offer</span>
      </button>

      <div id="bottom-controls">
        <button id="mic-toggle" class="toggle-btn"></button>
        <button id="camera-toggle" class="toggle-btn"></button>
      </div>
    </div>

    <!-- Paste Modal -->
    <div id="paste-modal" class="hidden">
      <h3>Paste Answer Code</h3>
      <textarea
        id="answer-input"
        placeholder="Paste the answer code here..."
      ></textarea>
      <div class="modal-actions">
        <button id="modal-cancel">Cancel</button>
        <button id="modal-connect">Connect</button>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast"></div>

    <!-- QR Code Modal -->
    <div id="qr-modal" class="hidden">
      <h3>QR Code</h3>
      <div id="qr-display"></div>
      <div class="qr-actions">
        <button id="qr-share">Share Image</button>
        <button id="qr-download">Download</button>
        <button id="qr-close">Close</button>
      </div>
    </div>

    <!-- QR Paste Modal -->
    <div id="qr-paste-modal" class="hidden">
      <h3 id="qr-paste-modal-title">Paste or Upload QR Code</h3>
      <div id="qr-paste-area">
        <p>üìã Paste QR image (Ctrl+V / Cmd+V)</p>
        <p>or</p>
        <button id="qr-upload-btn" class="control-btn" style="margin-top: 10px">
          Choose File
        </button>
      </div>
      <input type="file" id="qr-file-input" accept="image/*" />
      <div class="modal-actions" style="margin-top: 20px">
        <button id="qr-paste-cancel">Cancel</button>
      </div>
    </div>

    <script>
      const CONFIG = {
        // Timeouts (ms)
        TOAST_DURATION: 2000,
        AUTO_PASTE_DELAY: 100,
        MEDIA_NEGOTIATION_DELAY: 500,
        ICE_GATHERING_TIMEOUT: 5000,

        // Video settings
        VIDEO_WIDTH: 640,
        VIDEO_HEIGHT: 480,

        // QR Code settings
        QR_SIZE: 600,
        QR_ERROR_CORRECTION: 'L',
        QR_MARGIN: 4,

        // WebRTC settings
        ICE_CANDIDATE_POOL_SIZE: 10,

        // ICE servers
        ICE_SERVERS: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
        ],
      };

      const ICONS = {
        close: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>`,
        micOn: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>`,
        micOff: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="2" x2="22" y1="2" y2="22"/><path d="M18.89 13.23A7.12 7.12 0 0 0 19 12v-2"/><path d="M5 10v2a7 7 0 0 0 12 5"/><path d="M15 9.34V5a3 3 0 0 0-5.68-1.33"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12"/><line x1="12" x2="12" y1="19" y2="22"/></svg>`,
        cameraOn: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"/><rect x="2" y="6" width="14" height="12" rx="2"/></svg>`,
        cameraOff: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196"/><path d="M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2"/><path d="m2 2 20 20"/></svg>`,
        reload: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>`,
        share: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share-icon lucide-share"><path d="M12 2v13"/><path d="m16 6-4-4-4 4"/><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/></svg>`,
        paste: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download-icon lucide-download"><path d="M12 15V3"/><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="m7 10 5 5 5-5"/></svg>`,
      };

      class P2PWebRTC {
        constructor() {
          this.pc = null;
          this.dataChannel = null;
          this.mediaPc = null;
          this.localStream = null;
          this.role = null;
          this.connectionEstablished = false;

          // UI state
          this.videoMode = 'split'; // 'split', 'local-full', 'remote-full'
          this.buttonState = 'share'; // 'share', 'paste', 'close'
          this.qrPasteContext = 'offer'; // 'offer' or 'answer' - what type of QR we're expecting
          this.micEnabled = true;
          this.cameraEnabled = true;
          this.isLoading = false;
          this.isProcessing = false; // Prevent duplicate button clicks

          // DOM elements
          this.localVideo = document.getElementById('local-video');
          this.remoteVideo = document.getElementById('remote-video');
          this.videoGrid = document.getElementById('video-grid-view');
          this.controlsOverlay = document.getElementById('controls-overlay');
          this.reloadBtn = document.getElementById('reload-btn');
          this.topButton = document.getElementById('top-button');
          this.micToggle = document.getElementById('mic-toggle');
          this.cameraToggle = document.getElementById('camera-toggle');
          this.pasteModal = document.getElementById('paste-modal');
          this.answerInput = document.getElementById('answer-input');
          this.toast = document.getElementById('toast');

          // QR Code elements
          this.qrShowBtn = document.getElementById('qr-show-btn');
          this.qrPasteBtn = document.getElementById('qr-paste-btn');
          this.initialQrPasteBtn = document.getElementById(
            'initial-qr-paste-btn'
          );
          this.qrModal = document.getElementById('qr-modal');
          this.qrPasteModal = document.getElementById('qr-paste-modal');
          this.qrDisplay = document.getElementById('qr-display');
          this.qrFileInput = document.getElementById('qr-file-input');
          this.currentQRData = null;

          this.setupEventListeners();
          this.initializeIcons();
        }

        initializeIcons() {
          // Set initial icons
          this.reloadBtn.innerHTML = ICONS.reload;
          this.micToggle.innerHTML = ICONS.micOn;
          this.cameraToggle.innerHTML = ICONS.cameraOn;
          this.topButton.innerHTML =
            ICONS.share + '<span>Share Offer Link</span>';
        }

        setupEventListeners() {
          // Video click handlers for mode switching
          this.localVideo.addEventListener('click', () =>
            this.handleVideoClick('local')
          );
          this.remoteVideo.addEventListener('click', () =>
            this.handleVideoClick('remote')
          );

          // Reload button
          this.reloadBtn.addEventListener('click', () => this.reloadPage());

          // Top button
          this.topButton.addEventListener('click', () =>
            this.handleTopButtonClick()
          );

          // Mic and camera toggles
          this.micToggle.addEventListener('click', () => this.toggleMic());
          this.cameraToggle.addEventListener('click', () =>
            this.toggleCamera()
          );

          // Modal actions
          document
            .getElementById('modal-cancel')
            .addEventListener('click', () => {
              this.pasteModal.classList.add('hidden');
            });
          document
            .getElementById('modal-connect')
            .addEventListener('click', () => {
              this.processAnswer();
            });

          // Auto-paste detection
          this.answerInput.addEventListener('paste', () => {
            setTimeout(() => this.processAnswer(), CONFIG.AUTO_PASTE_DELAY);
          });

          // QR Code buttons
          this.qrShowBtn.addEventListener('click', () => this.showQRCode());
          this.qrPasteBtn.addEventListener('click', () =>
            this.showQRPasteModal('answer')
          );
          this.initialQrPasteBtn.addEventListener('click', () =>
            this.showQRPasteModal('offer')
          );

          // QR Modal actions
          document
            .getElementById('qr-share')
            .addEventListener('click', () => this.shareQRCode());
          document
            .getElementById('qr-download')
            .addEventListener('click', () => this.downloadQRCode());
          document
            .getElementById('qr-close')
            .addEventListener('click', () =>
              this.qrModal.classList.add('hidden')
            );

          // QR Paste Modal actions
          document
            .getElementById('qr-paste-cancel')
            .addEventListener('click', () =>
              this.qrPasteModal.classList.add('hidden')
            );
          document
            .getElementById('qr-upload-btn')
            .addEventListener('click', () => this.qrFileInput.click());
          this.qrFileInput.addEventListener('change', (e) =>
            this.handleQRFileUpload(e)
          );

          // QR Paste area - keyboard paste
          document.addEventListener('paste', (e) => {
            if (!this.qrPasteModal.classList.contains('hidden')) {
              this.handleQRPaste(e);
            }
          });
        }

        async init() {
          await this.setupCamera();

          if (location.hash) {
            // Hide initial QR paste button when opening an offer link
            this.initialQrPasteBtn.classList.add('hidden');
            await this.handleOffer();
          } else {
            // Initial QR paste button is visible by default
            await this.startAsInitiator();
          }
        }

        /**
         * Request and setup user's camera and microphone.
         * Displays video in local video element.
         * @returns {Promise<void>}
         */
        async setupCamera() {
          try {
            this.localStream = await navigator.mediaDevices.getUserMedia({
              video: { width: CONFIG.VIDEO_WIDTH, height: CONFIG.VIDEO_HEIGHT },
              audio: true,
            });
            this.localVideo.srcObject = this.localStream;
          } catch (err) {
            this.handleError('‚ùå Camera access denied', err);
          }
        }

        async startAsInitiator() {
          this.role = 'initiator';
          await this.createDataConnection();
          await this.generateOffer();
        }

        // Video mode toggling
        handleVideoClick(video) {
          if (this.videoMode === 'split') {
            // Switch to full-screen mode
            this.videoMode = video === 'local' ? 'local-full' : 'remote-full';
            this.updateVideoLayout();
          } else if (
            (this.videoMode === 'local-full' && video === 'remote') ||
            (this.videoMode === 'remote-full' && video === 'local')
          ) {
            // Swap full-screen and thumbnail
            this.videoMode = video === 'local' ? 'local-full' : 'remote-full';
            this.updateVideoLayout();
          } else {
            // Return to split mode
            this.videoMode = 'split';
            this.updateVideoLayout();
          }
        }

        updateVideoLayout() {
          this.videoGrid.className = '';
          this.localVideo.className = '';
          this.remoteVideo.className = '';

          if (!this.connectionEstablished) {
            this.remoteVideo.classList.add('hidden');
          }

          if (this.videoMode === 'split') {
            this.videoGrid.classList.add('mode-split-v');
          } else {
            this.videoGrid.classList.add('mode-full');
            if (this.videoMode === 'local-full') {
              this.localVideo.classList.add('full');
              this.remoteVideo.classList.add('thumbnail');
            } else {
              this.remoteVideo.classList.add('full');
              this.localVideo.classList.add('thumbnail');
            }
          }
        }

        // Button state machine
        async handleTopButtonClick() {
          if (this.isProcessing) {
            console.log('Already processing, ignoring click');
            return;
          }

          if (this.buttonState === 'share') {
            this.copyOfferLink();
          } else if (this.buttonState === 'paste') {
            await this.pasteAndConnect();
          } else if (this.buttonState === 'close') {
            this.closeConnection();
          }
        }

        async pasteAndConnect() {
          try {
            // Try to read from clipboard directly
            const clipboardText = await navigator.clipboard.readText();
            if (clipboardText && clipboardText.trim()) {
              this.answerInput.value = clipboardText.trim();
              await this.processAnswer();
            } else {
              // If clipboard is empty, show modal as fallback
              this.pasteModal.classList.remove('hidden');
              this.answerInput.focus();
            }
          } catch (err) {
            // If clipboard access denied or not available, show modal as fallback
            console.log('Clipboard access not available, showing modal:', err);
            this.pasteModal.classList.remove('hidden');
            this.answerInput.focus();
          }
        }

        async copyOfferLink() {
          const url = this.topButton.dataset.offerUrl;
          if (!url) return;

          // Try native Share API first
          if (navigator.share) {
            try {
              await navigator.share({
                url: url,
              });
              this.showToast('‚úÖ Link shared');
              this.setButtonState('paste');
              return;
            } catch (err) {
              // User cancelled or share failed, fall through to clipboard
              if (err.name !== 'AbortError') {
                console.error('Share failed:', err);
              }
            }
          }

          // Fallback to clipboard
          try {
            await navigator.clipboard.writeText(url);
            this.showToast('‚úÖ Link copied to clipboard');
            this.setButtonState('paste');
          } catch (err) {
            console.error('Copy failed:', err);
            this.showToast('‚ùå Failed to copy link');
          }
        }

        async shareAnswerCode(code) {
          if (!code) return;

          // Try native Share API first
          if (navigator.share) {
            try {
              await navigator.share({
                title: 'P2P WebRTC Answer Code',
                text: `${code}`,
              });
              this.showToast('‚úÖ Answer code shared');
              return;
            } catch (err) {
              // User cancelled or share failed, fall through to clipboard
              if (err.name !== 'AbortError') {
                console.error('Share failed:', err);
              }
            }
          }

          // Fallback to clipboard
          try {
            await navigator.clipboard.writeText(code);
            this.showToast('‚úÖ Answer code copied to clipboard');
          } catch (err) {
            console.error('Copy failed:', err);
            this.showToast('‚ùå Failed to copy');
          }
        }

        setButtonState(state) {
          this.buttonState = state;
          if (state === 'share') {
            this.topButton.innerHTML =
              ICONS.share + '<span>Share Offer Link</span>';
            this.topButton.classList.add('primary');
            this.topButton.classList.remove('close-btn');
            // Show both QR buttons in share state for QR code workflow
            // User can show their offer QR AND paste the answer QR
            this.qrShowBtn.classList.remove('hidden');
            this.qrPasteBtn.classList.remove('hidden'); // Show answer paste button
            // Keep initial QR paste button visible in share state
            // (user can still paste someone else's offer QR code)
          } else if (state === 'paste') {
            this.topButton.innerHTML =
              ICONS.paste + '<span>Paste Answer Code</span>';
            this.topButton.classList.add('primary');
            this.topButton.classList.remove('close-btn');
            // Show QR paste button for answer
            this.qrShowBtn.classList.add('hidden');
            this.qrPasteBtn.classList.remove('hidden');
            // Hide initial QR paste button (we're now waiting for answer, not offer)
            this.initialQrPasteBtn.classList.add('hidden');
          } else if (state === 'close') {
            this.topButton.innerHTML = ICONS.close;
            this.topButton.classList.remove('primary');
            this.topButton.classList.add('close-btn');
            // Hide QR buttons when connected
            this.qrShowBtn.classList.add('hidden');
            this.qrPasteBtn.classList.add('hidden');
            this.initialQrPasteBtn.classList.add('hidden');

            // Move mic/camera controls to top
            const bottomControls = document.getElementById('bottom-controls');
            bottomControls.classList.add('top-position');
          }
        }

        // Mic and camera toggles
        toggleMic() {
          this.micEnabled = !this.micEnabled;
          if (this.localStream) {
            this.localStream.getAudioTracks().forEach((track) => {
              track.enabled = this.micEnabled;
            });
          }
          this.micToggle.innerHTML = this.micEnabled
            ? ICONS.micOn
            : ICONS.micOff;
          this.micToggle.classList.toggle('off', !this.micEnabled);
        }

        toggleCamera() {
          this.cameraEnabled = !this.cameraEnabled;
          if (this.localStream) {
            this.localStream.getVideoTracks().forEach((track) => {
              track.enabled = this.cameraEnabled;
            });
          }
          this.cameraToggle.innerHTML = this.cameraEnabled
            ? ICONS.cameraOn
            : ICONS.cameraOff;
          this.cameraToggle.classList.toggle('off', !this.cameraEnabled);
        }

        showToast(message) {
          this.toast.textContent = message;
          this.toast.classList.add('show');
          setTimeout(() => {
            this.toast.classList.remove('show');
          }, CONFIG.TOAST_DURATION);
        }

        /**
         * Handle errors consistently: log to console and show user-friendly message.
         * @param {string} userMessage - Message to show to the user
         * @param {Error|string} error - Error object or message to log
         * @param {boolean} shouldCleanup - Whether to clean up connections (default: false)
         */
        handleError(userMessage, error, shouldCleanup = false) {
          console.error(userMessage, error);
          this.showToast(userMessage);
          this.setLoading(false);
          this.isProcessing = false;

          if (shouldCleanup) {
            this.cleanup();
          }
        }

        setLoading(loading, statusText = '') {
          this.isLoading = loading;
          if (loading) {
            this.topButton.classList.add('loading');
            this.topButton.disabled = true;
            if (statusText) {
              // Save original HTML and update only the text part
              this.topButton.dataset.originalHTML = this.topButton.innerHTML;
              const span = this.topButton.querySelector('span');
              if (span) {
                span.textContent = statusText;
              } else {
                this.topButton.textContent = statusText;
              }
            }
          } else {
            this.topButton.classList.remove('loading');
            this.topButton.disabled = false;
            if (this.topButton.dataset.originalHTML) {
              this.topButton.innerHTML = this.topButton.dataset.originalHTML;
              delete this.topButton.dataset.originalHTML;
            }
          }
        }

        reloadPage() {
          // Clear hash if it's an offer link, then reload
          if (location.hash) {
            history.replaceState(null, '', location.pathname);
          }
          location.reload();
        }

        /**
         * Clean up peer connections and resources.
         * Call this before creating new connections or on errors.
         */
        cleanup() {
          console.log('üßπ Cleaning up peer connections...');

          // Close data peer connection
          if (this.pc) {
            this.pc.close();
            this.pc = null;
          }

          // Close media peer connection
          if (this.mediaPc) {
            this.mediaPc.close();
            this.mediaPc = null;
          }

          // Close data channel
          if (this.dataChannel) {
            this.dataChannel.close();
            this.dataChannel = null;
          }

          this.connectionEstablished = false;
          this.isProcessing = false;
          console.log('‚úÖ Cleanup complete');
        }

        closeConnection() {
          this.cleanup();
          this.reloadPage();
        }

        /**
         * Create the initial data channel peer connection.
         * This is used to exchange media negotiation messages.
         * @returns {Promise<void>}
         */
        async createDataConnection() {
          this.pc = new RTCPeerConnection({
            iceServers: CONFIG.ICE_SERVERS,
            iceCandidatePoolSize: CONFIG.ICE_CANDIDATE_POOL_SIZE,
          });

          this.pc.oniceconnectionstatechange = () => {
            console.log('ICE:', this.pc.iceConnectionState);
            // Handle ICE connection failures
            if (this.pc.iceConnectionState === 'failed' || this.pc.iceConnectionState === 'closed') {
              console.error('‚ùå ICE connection failed or closed');
              this.showToast('‚ùå Connection failed');
              this.cleanup();
            }
          };

          if (this.role === 'initiator') {
            this.dataChannel = this.pc.createDataChannel('media', {
              ordered: true,
            });
            this.setupDataChannel(this.dataChannel);
          }

          this.pc.ondatachannel = (event) => {
            this.dataChannel = event.channel;
            this.setupDataChannel(this.dataChannel);
          };

          this.pc.onconnectionstatechange = () => {
            console.log('PC:', this.pc.connectionState);
            if (
              this.pc.connectionState === 'connected' &&
              !this.connectionEstablished
            ) {
              this.connectionEstablished = true;
              setTimeout(() => this.startMediaNegotiation(), CONFIG.MEDIA_NEGOTIATION_DELAY);
            }
          };
        }

        setupDataChannel(channel) {
          channel.onopen = () => {
            console.log('DataChannel opened');
            this.connectionEstablished = true;
          };

          channel.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'media-offer') {
              await this.handleMediaOffer(data);
            } else if (data.type === 'media-answer') {
              await this.handleMediaAnswer(data);
            }
          };
        }

        /**
         * Generate WebRTC offer and create shareable URL.
         * Encodes the offer as base64 in the URL hash.
         * @returns {Promise<void>}
         */
        async generateOffer() {
          this.setLoading(true, 'Generating offer');

          const offer = await this.pc.createOffer();
          await this.pc.setLocalDescription(offer);
          await this.waitForICE();

          const offerData = {
            type: 'offer',
            sdp: this.pc.localDescription.sdp,
          };

          const encoded = btoa(JSON.stringify(offerData));
          const url = `${window.location.origin}${window.location.pathname}#${encoded}`;

          this.topButton.dataset.offerUrl = url;
          this.setLoading(false);
          this.setButtonState('share');
          this.showToast('Offer ready to share');
        }

        async handleOffer() {
          const hashData = location.hash.slice(1);
          await this.handleOfferFromHash(hashData);
        }

        async handleOfferFromHash(hashData) {
          try {
            this.setLoading(true, 'Processing offer');
            console.log('üì• Received offer via QR code');

            const data = JSON.parse(atob(hashData));

            if (data.type !== 'offer') {
              this.showToast('‚ùå Invalid offer data');
              this.setLoading(false);
              return;
            }

            console.log('‚úÖ Offer data valid, becoming responder');
            this.role = 'responder';

            await this.createDataConnection();
            console.log('üì° Data connection created');

            await this.pc.setRemoteDescription({
              type: 'offer',
              sdp: data.sdp,
            });

            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);
            await this.waitForICE();

            const answerData = {
              type: 'answer',
              sdp: this.pc.localDescription.sdp,
            };

            const encoded = btoa(JSON.stringify(answerData));

            // Clear loading first, then set button text
            this.setLoading(false);

            // Store answer code for share button and show "Show QR" button for answer
            this.topButton.dataset.answerCode = encoded;
            this.topButton.innerHTML =
              ICONS.share + '<span>Share Answer Code</span>';
            this.topButton.classList.add('primary');
            this.topButton.classList.remove('close-btn');
            this.topButton.onclick = async () => {
              await this.shareAnswerCode(encoded);
            };

            // Show QR button for sharing answer code
            this.qrShowBtn.classList.remove('hidden');
            this.qrPasteBtn.classList.add('hidden');

            this.showToast('Answer code ready to share');
            this.isProcessing = false; // Clear processing flag after becoming responder
          } catch (err) {
            this.handleError('‚ùå Error processing offer', err, true);
          }
        }

        /**
         * Process answer code from responder to complete connection.
         * Decodes base64 answer and sets as remote description.
         * @returns {Promise<void>}
         */
        async processAnswer() {
          if (this.isProcessing) {
            console.log('Already processing answer, ignoring');
            return;
          }

          const input = this.answerInput.value.trim();
          if (!input) return;

          this.isProcessing = true;

          try {
            const data = JSON.parse(atob(input));

            if (data.type !== 'answer') {
              this.showToast('‚ùå Invalid answer code');
              this.isProcessing = false;
              return;
            }

            this.pasteModal.classList.add('hidden');
            this.setLoading(true, 'Connecting');
            this.showToast('‚è≥ Connecting...');

            await this.pc.setRemoteDescription({
              type: 'answer',
              sdp: data.sdp,
            });

            this.answerInput.value = '';
            // Loading state will be cleared when connection is established
            // isProcessing will be cleared when connection completes
          } catch (err) {
            this.handleError('‚ùå Invalid answer code', err);
          }
        }

        async startMediaNegotiation() {
          console.log('Starting media negotiation, role:', this.role);

          if (this.role === 'initiator') {
            await this.sendMediaOffer();
          }
        }

        /**
         * Create and configure media peer connection with local stream.
         * @returns {RTCPeerConnection} Configured media peer connection
         */
        createMediaPeerConnection() {
          const mediaPc = new RTCPeerConnection({
            iceServers: CONFIG.ICE_SERVERS,
            iceCandidatePoolSize: CONFIG.ICE_CANDIDATE_POOL_SIZE,
          });

          // Add local stream tracks if available
          if (this.localStream) {
            this.localStream.getTracks().forEach((track) => {
              mediaPc.addTrack(track, this.localStream);
            });
          }

          // Set up remote stream handler
          mediaPc.ontrack = (event) => {
            this.showConnectedState(event.streams[0]);
          };

          return mediaPc;
        }

        async sendMediaOffer() {
          this.mediaPc = this.createMediaPeerConnection();

          const offer = await this.mediaPc.createOffer();
          await this.mediaPc.setLocalDescription(offer);
          await this.waitForICE(this.mediaPc);

          const mediaOffer = {
            type: 'media-offer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          this.dataChannel.send(JSON.stringify(mediaOffer));
        }

        async handleMediaOffer(data) {
          this.mediaPc = this.createMediaPeerConnection();

          await this.mediaPc.setRemoteDescription({
            type: 'offer',
            sdp: data.sdp,
          });

          const answer = await this.mediaPc.createAnswer();
          await this.mediaPc.setLocalDescription(answer);
          await this.waitForICE(this.mediaPc);

          const mediaAnswer = {
            type: 'media-answer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          this.dataChannel.send(JSON.stringify(mediaAnswer));
        }

        async handleMediaAnswer(data) {
          await this.mediaPc.setRemoteDescription({
            type: 'answer',
            sdp: data.sdp,
          });
        }

        showConnectedState(remoteStream) {
          this.remoteVideo.srcObject = remoteStream;
          this.remoteVideo.classList.remove('hidden');
          this.connectionEstablished = true;

          // Enable split view mode when connected
          this.videoGrid.classList.add('mode-split-v');

          // Enable click on local video after connection
          this.localVideo.classList.remove('no-click');

          // Clear loading state
          this.setLoading(false);
          this.isProcessing = false;

          this.setButtonState('close');
          this.showToast('üéâ Connected!');
          this.updateVideoLayout();
        }

        /**
         * Wait for ICE candidate gathering to complete with timeout.
         * Resolves when gathering is complete or timeout is reached.
         * @param {RTCPeerConnection} pc - The peer connection to wait for
         * @returns {Promise<void>}
         */
        waitForICE(pc = this.pc) {
          return new Promise((resolve) => {
            if (pc.iceGatheringState === 'complete') {
              console.log('ICE gathering already complete');
              resolve();
              return;
            }

            let timeout;
            const onStateChange = () => {
              console.log('ICE gathering state:', pc.iceGatheringState);
              if (pc.iceGatheringState === 'complete') {
                pc.removeEventListener('icegatheringstatechange', onStateChange);
                clearTimeout(timeout);
                console.log('‚úÖ ICE gathering complete');
                resolve();
              }
            };

            pc.addEventListener('icegatheringstatechange', onStateChange);

            // Timeout fallback - proceed even if gathering incomplete
            timeout = setTimeout(() => {
              pc.removeEventListener('icegatheringstatechange', onStateChange);
              console.log('‚è±Ô∏è ICE gathering timeout reached, proceeding anyway');
              resolve();
            }, CONFIG.ICE_GATHERING_TIMEOUT);
          });
        }

        /**
         * Generate and display QR code for current offer or answer.
         * Automatically detects whether to encode offer URL or answer code.
         * @returns {Promise<void>}
         */
        async showQRCode() {
          // Check if QRCode library is loaded
          if (typeof QRCode === 'undefined') {
            this.showToast('‚ùå QR Code library not loaded');
            console.error(
              'QRCode library is not available. Check if CDN is accessible.'
            );
            return;
          }

          let dataToEncode;
          let qrType = 'unknown';

          // Smart detection: check what data is available
          // Priority: answer code > offer URL (in case both exist)
          if (this.topButton.dataset.answerCode) {
            // Responder has an answer code to share
            dataToEncode = this.topButton.dataset.answerCode;
            qrType = 'answer';
          } else if (this.topButton.dataset.offerUrl) {
            // Initiator has an offer URL to share
            dataToEncode = this.topButton.dataset.offerUrl;
            qrType = 'offer';
          } else {
            dataToEncode = '';
          }

          console.log(
            `Generating QR code for ${qrType}:`,
            dataToEncode.substring(0, 50) + '...'
          );
          console.log('Data length:', dataToEncode.length);
          console.log('Data type check:', dataToEncode.startsWith('http') ? 'URL' : 'base64');

          if (!dataToEncode) {
            this.showToast('‚ùå No data to generate QR code');
            return;
          }

          try {
            // Clear previous QR
            this.qrDisplay.innerHTML = '';

            // Generate QR code
            const canvas = document.createElement('canvas');

            // Call QRCode.toCanvas with proper syntax
            await new Promise((resolve, reject) => {
              QRCode.toCanvas(
                canvas,
                dataToEncode,
                {
                  errorCorrectionLevel: CONFIG.QR_ERROR_CORRECTION,
                  width: CONFIG.QR_SIZE,
                  margin: CONFIG.QR_MARGIN,
                  color: {
                    dark: '#000000',
                    light: '#FFFFFF',
                  },
                },
                (error) => {
                  if (error) {
                    reject(error);
                  } else {
                    resolve();
                  }
                }
              );
            });

            this.qrDisplay.appendChild(canvas);
            this.currentQRData = canvas;
            this.qrModal.classList.remove('hidden');
            this.showToast('‚úÖ QR Code generated');
            console.log('QR code generated successfully');
          } catch (err) {
            this.handleError('‚ùå Failed to generate QR code', err);
          }
        }

        async shareQRCode() {
          if (!this.currentQRData) return;

          try {
            // Convert canvas to blob
            const blob = await new Promise((resolve) => {
              this.currentQRData.toBlob(resolve, 'image/png');
            });

            const file = new File([blob], 'webrtc-connection.png', {
              type: 'image/png',
            });

            console.log('Attempting to share QR code...');
            console.log('Navigator.share available:', !!navigator.share);

            // Try native share API with files
            if (navigator.share) {
              const canShareFiles =
                navigator.canShare && navigator.canShare({ files: [file] });
              console.log('Can share files:', canShareFiles);

              if (canShareFiles) {
                await navigator.share({
                  files: [file],
                  title: 'WebRTC Connection QR Code',
                  text: 'Scan this QR code to connect via WebRTC',
                });
                this.showToast('‚úÖ QR Code shared');
                return;
              } else {
                // Try sharing without files (just trigger share sheet)
                console.log('Trying share without files...');
                const dataUrl = this.currentQRData.toDataURL('image/png');
                await navigator.share({
                  title: 'WebRTC Connection QR Code',
                  text: 'Please download the QR code from the browser',
                });
                this.showToast('üìã Please download QR code manually');
                return;
              }
            }

            // Fallback to clipboard
            console.log('Falling back to clipboard...');
            if (navigator.clipboard && navigator.clipboard.write) {
              await navigator.clipboard.write([
                new ClipboardItem({ 'image/png': blob }),
              ]);
              this.showToast('‚úÖ QR Code copied to clipboard');
            } else {
              this.showToast('‚ùå Please use Download button');
            }
          } catch (err) {
            this.handleError('‚ùå Share failed. Use Download button', err);
          }
        }

        async downloadQRCode() {
          if (!this.currentQRData) return;

          try {
            const url = this.currentQRData.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'webrtc-connection.png';
            link.href = url;
            link.click();
            this.showToast('‚úÖ QR Code downloaded');
          } catch (err) {
            this.handleError('‚ùå Failed to download QR code', err);
          }
        }

        // QR Code Decoding
        showQRPasteModal(context = 'offer') {
          this.qrPasteContext = context;
          const titleEl = document.getElementById('qr-paste-modal-title');
          if (context === 'offer') {
            titleEl.textContent = 'Paste or Upload Offer QR Code';
          } else {
            titleEl.textContent = 'Paste or Upload Answer QR Code';
          }
          this.qrPasteModal.classList.remove('hidden');
        }

        async handleQRPaste(event) {
          const items = event.clipboardData?.items;
          if (!items) return;

          for (const item of items) {
            if (item.type.startsWith('image/')) {
              event.preventDefault();
              const blob = item.getAsFile();
              await this.decodeQRFromBlob(blob);
              break;
            }
          }
        }

        async handleQRFileUpload(event) {
          const file = event.target.files?.[0];
          if (!file) return;

          await this.decodeQRFromBlob(file);
          this.qrFileInput.value = ''; // Reset input
        }

        /**
         * Decode QR code from image blob and process offer or answer.
         * Uses context (offer/answer) to validate and route the decoded data.
         * @param {Blob} blob - Image blob containing QR code
         * @returns {Promise<void>}
         */
        async decodeQRFromBlob(blob) {
          if (this.isProcessing) {
            console.log('Already processing QR code, ignoring');
            return;
          }

          this.isProcessing = true;

          try {
            this.showToast('üîç Decoding QR code...');

            const imageDataURL = await this.blobToDataURL(blob);
            const decoded = await this.decodeQRFromImage(imageDataURL);

            if (decoded) {
              this.qrPasteModal.classList.add('hidden');

              // Process based on expected context
              if (this.qrPasteContext === 'offer') {
                // Expecting an offer QR code (URL with hash)
                console.log('üì• Processing offer QR code');

                if (decoded.startsWith('http')) {
                  try {
                    const url = new URL(decoded);
                    if (url.hash) {
                      const offerData = url.hash.slice(1);
                      console.log(
                        '‚úÖ Valid offer URL, hash length:',
                        offerData.length
                      );

                      // Hide initial QR paste button
                      this.initialQrPasteBtn.classList.add('hidden');

                      // Close existing peer connection if we were starting as initiator
                      if (this.pc && this.role === 'initiator') {
                        console.log(
                          '‚ö†Ô∏è Closing initiator connection to become responder'
                        );
                        this.pc.close();
                        this.pc = null;
                        this.dataChannel = null;
                      }

                      // Set the hash using replaceState to avoid polluting browser history
                      history.replaceState(null, '', `#${offerData}`);

                      // Directly process the offer
                      await this.handleOfferFromHash(offerData);
                      this.showToast('‚úÖ Offer received');
                      return;
                    }
                  } catch (e) {
                    console.error('Invalid offer URL:', e);
                    this.showToast('‚ùå Invalid offer QR code');
                    this.isProcessing = false;
                    return;
                  }
                } else {
                  // Try to decode it as base64 offer data directly
                  try {
                    const data = JSON.parse(atob(decoded));
                    if (data.type === 'offer') {
                      console.log('‚úÖ Valid base64 offer data');
                      await this.handleOfferFromHash(decoded);
                      this.showToast('‚úÖ Offer received');
                      return;
                    }
                  } catch (e) {
                    console.error('Not a valid offer:', e);
                  }
                  this.showToast("‚ùå This doesn't look like an offer QR code");
                  this.isProcessing = false;
                  return;
                }
              } else if (this.qrPasteContext === 'answer') {
                // Expecting an answer QR code (base64 encoded answer)
                console.log(
                  'üì• Processing answer QR code, length:',
                  decoded.length
                );

                // Answer should be base64, not a URL
                if (decoded.startsWith('http')) {
                  this.showToast('‚ùå This looks like an offer, not an answer');
                  this.isProcessing = false;
                  return;
                }

                try {
                  const data = JSON.parse(atob(decoded));
                  if (data.type === 'answer') {
                    console.log('‚úÖ Valid answer data');
                    this.answerInput.value = decoded;
                    this.isProcessing = false; // Clear before calling processAnswer
                    await this.processAnswer();
                    this.showToast('‚úÖ Answer received');
                    return;
                  } else {
                    this.showToast(
                      "‚ùå This doesn't look like an answer QR code"
                    );
                    this.isProcessing = false;
                    return;
                  }
                } catch (e) {
                  console.error('Invalid answer data:', e);
                  this.showToast('‚ùå Invalid answer QR code');
                  this.isProcessing = false;
                  return;
                }
              }

              this.showToast('‚úÖ QR code decoded');
              this.isProcessing = false;
            } else {
              this.showToast('‚ùå No QR code found in image');
              this.isProcessing = false;
            }
          } catch (err) {
            this.handleError('‚ùå Failed to decode QR code', err);
          }
        }

        async decodeQRFromImage(imageDataURL) {
          return new Promise((resolve) => {
            const img = new Image();
            img.onload = async () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');

              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);

              // Try ZXing first (more powerful for dense QR codes)
              if (typeof ZXing !== 'undefined') {
                try {
                  console.log('Trying ZXing decoder...');
                  const codeReader = new ZXing.BrowserQRCodeReader();
                  const result = await codeReader.decodeFromImageElement(img);

                  if (result && result.text) {
                    console.log('‚úÖ QR code decoded successfully with ZXing!');
                    console.log('Data length:', result.text.length);
                    console.log(
                      'First 100 chars:',
                      result.text.substring(0, 100)
                    );
                    resolve(result.text);
                    return;
                  }
                } catch (err) {
                  console.log('ZXing failed:', err.message);
                }
              }

              // Fallback to jsQR with multiple scales
              if (typeof jsQR !== 'undefined') {
                console.log('Trying jsQR decoder...');
                const scales = [1, 1.5, 2, 3, 4, 0.75, 0.5];

                for (const scale of scales) {
                  canvas.width = img.width * scale;
                  canvas.height = img.height * scale;

                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.imageSmoothingEnabled = false;
                  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                  const imageData = ctx.getImageData(
                    0,
                    0,
                    canvas.width,
                    canvas.height
                  );

                  console.log(
                    `Trying jsQR at scale ${scale}, size: ${canvas.width}x${canvas.height}`
                  );

                  const code = jsQR(
                    imageData.data,
                    imageData.width,
                    imageData.height,
                    {
                      inversionAttempts: 'attemptBoth',
                    }
                  );

                  if (code) {
                    console.log(
                      '‚úÖ QR code decoded successfully with jsQR at scale',
                      scale
                    );
                    console.log('Data length:', code.data.length);
                    console.log(
                      'First 100 chars:',
                      code.data.substring(0, 100)
                    );
                    resolve(code.data);
                    return;
                  }
                }
              }

              console.log('‚ùå No QR code found with any decoder');
              resolve(null);
            };
            img.onerror = (err) => {
              console.error('Image load error:', err);
              resolve(null);
            };
            img.src = imageDataURL;
          });
        }

        blobToDataURL(blob) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(blob);
          });
        }
      }

      const rtc = new P2PWebRTC();
      window.addEventListener('load', () => rtc.init());
    </script>
  </body>
</html>
