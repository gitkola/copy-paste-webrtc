<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>P2P WebRTC</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      html,
      body {
        width: 100svw;
        height: 100svh;
        overflow: hidden;
        position: fixed;
        -webkit-user-select: none;
        user-select: none;
        touch-action: manipulation;
      }

      body {
        font-family: monospace, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
        background: #0a0a0a;
        color: #fff;
      }

      /* Video Grid View Layer - Bottom */
      #video-grid-view {
        position: absolute;
        top: 0;
        left: 0;
        width: 100svw;
        height: 100svh;
        background: #0a0a0a;
        display: flex;
        overflow: hidden;
      }

      /* 50/50 Mode */
      #video-grid-view.mode-split-v {
        flex-direction: column;
      }

      #video-grid-view.mode-split-v video {
        width: 100%;
        height: 50%;
      }

      #video-grid-view.mode-split-h {
        flex-direction: row;
      }

      #video-grid-view.mode-split-h video {
        width: 50%;
        height: 100%;
      }

      /* Full-screen Mode */
      #video-grid-view.mode-full video.full {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      #video-grid-view.mode-full video.thumbnail {
        width: 120px;
        height: 160px;
        position: absolute;
        bottom: 80px;
        right: 20px;
        z-index: 2;
        border: 2px solid #00ff88;
        border-radius: 12px;
      }

      video {
        background: #1a1a1a;
        object-fit: cover;
        cursor: pointer;
        transition: all 0.3s ease;
        touch-action: manipulation;
      }

      video.hidden {
        display: none;
      }

      /* Controls Overlay Layer - Top */
      #controls-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 10;
      }

      #controls-overlay.always-visible {
        /* Keep controls always visible when connected */
      }

      .control-btn {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        padding: 14px 24px;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        touch-action: manipulation;
      }

      .control-btn:active {
        transform: scale(0.95);
        background: rgba(0, 0, 0, 0.9);
      }

      .control-btn.primary {
        background: linear-gradient(135deg, #00ff88, #00cc66);
        color: #000;
        border-color: transparent;
      }

      #top-button {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        transition: all 0.3s ease;
      }

      #top-button.close-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff4444, #cc0000);
        color: #fff;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        font-weight: 700;
        border: 2px solid rgba(255, 255, 255, 0.3);
        top: 20px;
        right: 20px;
        left: auto;
        transform: none;
      }

      #bottom-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 20px;
        pointer-events: auto;
        transition: all 0.3s ease;
      }

      #bottom-controls.top-position {
        bottom: auto;
        top: 20px;
        left: 20px;
        transform: none;
      }

      .toggle-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        pointer-events: auto;
        touch-action: manipulation;
      }

      .toggle-btn:active {
        transform: scale(0.9);
      }

      .toggle-btn.off {
        background: rgba(255, 0, 0, 0.3);
        border-color: rgba(255, 0, 0, 0.5);
      }

      /* Modal */
      #paste-modal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 400px;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 24px;
        z-index: 20;
        pointer-events: auto;
      }

      #paste-modal.hidden {
        display: none;
      }

      #paste-modal h3 {
        margin-bottom: 16px;
        font-size: 18px;
        color: #fff;
      }

      #answer-input {
        width: 100%;
        min-height: 120px;
        background: #1a1a1a;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 12px;
        color: #fff;
        font-size: 13px;
        font-family: 'SF Mono', Monaco, monospace;
        resize: vertical;
        margin-bottom: 16px;
      }

      #answer-input:focus {
        outline: none;
        border-color: #00ff88;
      }

      .modal-actions {
        display: flex;
        gap: 12px;
      }

      .modal-actions button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
      }

      #modal-connect {
        background: linear-gradient(135deg, #00ff88, #00cc66);
        color: #000;
      }

      #modal-cancel {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      /* Toast */
      #toast {
        position: absolute;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 12px 24px;
        border-radius: 24px;
        font-size: 14px;
        z-index: 30;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }

      #toast.show {
        opacity: 1;
      }

      /* Landscape mode adjustments */
      @media (orientation: landscape) {
        #video-grid-view.mode-split-v {
          flex-direction: row;
        }

        #video-grid-view.mode-split-v video {
          width: 50%;
          height: 100%;
        }

        #video-grid-view.mode-full video.thumbnail {
          width: 160px;
          height: 120px;
        }
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Video Grid View Layer -->
    <div id="video-grid-view" class="mode-split-v">
      <video id="local-video" autoplay muted playsinline></video>
      <video id="remote-video" autoplay playsinline></video>
    </div>

    <!-- Controls Overlay Layer -->
    <div id="controls-overlay">
      <button id="top-button" class="control-btn primary">
        Share Offer Link
      </button>

      <div id="bottom-controls">
        <button id="mic-toggle" class="toggle-btn">ðŸŽ¤</button>
        <button id="camera-toggle" class="toggle-btn">ðŸ“¹</button>
      </div>
    </div>

    <!-- Paste Modal -->
    <div id="paste-modal" class="hidden">
      <h3>Paste Answer Code</h3>
      <textarea
        id="answer-input"
        placeholder="Paste the answer code here..."
      ></textarea>
      <div class="modal-actions">
        <button id="modal-cancel">Cancel</button>
        <button id="modal-connect">Connect</button>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast"></div>

    <script>
      class P2PWebRTC {
        constructor() {
          this.pc = null;
          this.dataChannel = null;
          this.mediaPc = null;
          this.localStream = null;
          this.role = null;
          this.connectionEstablished = false;

          // UI state
          this.videoMode = 'split'; // 'split', 'local-full', 'remote-full'
          this.buttonState = 'share'; // 'share', 'paste', 'close'
          this.micEnabled = true;
          this.cameraEnabled = true;
          this.controlsVisible = true;
          this.controlsTimer = null;

          // DOM elements
          this.localVideo = document.getElementById('local-video');
          this.remoteVideo = document.getElementById('remote-video');
          this.videoGrid = document.getElementById('video-grid-view');
          this.controlsOverlay = document.getElementById('controls-overlay');
          this.topButton = document.getElementById('top-button');
          this.micToggle = document.getElementById('mic-toggle');
          this.cameraToggle = document.getElementById('camera-toggle');
          this.pasteModal = document.getElementById('paste-modal');
          this.answerInput = document.getElementById('answer-input');
          this.toast = document.getElementById('toast');

          this.iceServers = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
          ];

          this.setupEventListeners();
        }

        setupEventListeners() {
          // Video click handlers for mode switching
          this.localVideo.addEventListener('click', () =>
            this.handleVideoClick('local')
          );
          this.remoteVideo.addEventListener('click', () =>
            this.handleVideoClick('remote')
          );

          // Top button
          this.topButton.addEventListener('click', () =>
            this.handleTopButtonClick()
          );

          // Mic and camera toggles
          this.micToggle.addEventListener('click', () => this.toggleMic());
          this.cameraToggle.addEventListener('click', () =>
            this.toggleCamera()
          );

          // Modal actions
          document
            .getElementById('modal-cancel')
            .addEventListener('click', () => {
              this.pasteModal.classList.add('hidden');
            });
          document
            .getElementById('modal-connect')
            .addEventListener('click', () => {
              this.processAnswer();
            });

          // Disabled screen tap to toggle controls - controls are always visible

          // Auto-paste detection
          this.answerInput.addEventListener('paste', () => {
            setTimeout(() => this.processAnswer(), 100);
          });
        }

        async init() {
          await this.setupCamera();

          if (location.hash) {
            await this.handleOffer();
          } else {
            await this.startAsInitiator();
          }
        }

        async setupCamera() {
          try {
            this.localStream = await navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 480 },
              audio: true,
            });
            this.localVideo.srcObject = this.localStream;
          } catch (err) {
            console.error('Camera error:', err);
            this.showToast('Camera access denied');
          }
        }

        async startAsInitiator() {
          this.role = 'initiator';
          this.remoteVideo.classList.add('hidden');
          await this.createDataConnection();
          await this.generateOffer();
        }

        // Video mode toggling
        handleVideoClick(video) {
          if (this.videoMode === 'split') {
            // Switch to full-screen mode
            this.videoMode = video === 'local' ? 'local-full' : 'remote-full';
            this.updateVideoLayout();
          } else if (
            (this.videoMode === 'local-full' && video === 'remote') ||
            (this.videoMode === 'remote-full' && video === 'local')
          ) {
            // Swap full-screen and thumbnail
            this.videoMode = video === 'local' ? 'local-full' : 'remote-full';
            this.updateVideoLayout();
          } else {
            // Return to split mode
            this.videoMode = 'split';
            this.updateVideoLayout();
          }
        }

        updateVideoLayout() {
          this.videoGrid.className = '';
          this.localVideo.className = '';
          this.remoteVideo.className = '';

          if (!this.connectionEstablished) {
            this.remoteVideo.classList.add('hidden');
          }

          if (this.videoMode === 'split') {
            this.videoGrid.classList.add('mode-split-v');
          } else {
            this.videoGrid.classList.add('mode-full');
            if (this.videoMode === 'local-full') {
              this.localVideo.classList.add('full');
              this.remoteVideo.classList.add('thumbnail');
            } else {
              this.remoteVideo.classList.add('full');
              this.localVideo.classList.add('thumbnail');
            }
          }
        }

        // Button state machine
        handleTopButtonClick() {
          if (this.buttonState === 'share') {
            this.copyOfferLink();
          } else if (this.buttonState === 'paste') {
            this.pasteModal.classList.remove('hidden');
            this.answerInput.focus();
          } else if (this.buttonState === 'close') {
            this.closeConnection();
          }
        }

        async copyOfferLink() {
          const url = this.topButton.dataset.offerUrl;
          if (!url) return;

          // Try native Share API first
          if (navigator.share) {
            try {
              await navigator.share({
                url: url,
              });
              this.showToast('âœ… Link shared');
              this.setButtonState('paste');
              return;
            } catch (err) {
              // User cancelled or share failed, fall through to clipboard
              if (err.name !== 'AbortError') {
                console.error('Share failed:', err);
              }
            }
          }

          // Fallback to clipboard
          try {
            await navigator.clipboard.writeText(url);
            this.showToast('âœ… Link copied to clipboard');
            this.setButtonState('paste');
          } catch (err) {
            console.error('Copy failed:', err);
            this.showToast('âŒ Failed to copy link');
          }
        }

        async shareAnswerCode(code) {
          if (!code) return;

          // Try native Share API first
          if (navigator.share) {
            try {
              await navigator.share({
                title: 'P2P WebRTC Answer Code',
                text: `Here's my answer code:\n\n${code}`,
              });
              this.showToast('âœ… Answer code shared');
              return;
            } catch (err) {
              // User cancelled or share failed, fall through to clipboard
              if (err.name !== 'AbortError') {
                console.error('Share failed:', err);
              }
            }
          }

          // Fallback to clipboard
          try {
            await navigator.clipboard.writeText(code);
            this.showToast('âœ… Answer code copied to clipboard');
          } catch (err) {
            console.error('Copy failed:', err);
            this.showToast('âŒ Failed to copy');
          }
        }

        setButtonState(state) {
          this.buttonState = state;
          if (state === 'share') {
            this.topButton.textContent = 'Share Offer Link';
            this.topButton.classList.add('primary');
            this.topButton.classList.remove('close-btn');
          } else if (state === 'paste') {
            this.topButton.textContent = 'Paste Answer Code';
            this.topButton.classList.add('primary');
            this.topButton.classList.remove('close-btn');
          } else if (state === 'close') {
            this.topButton.textContent = 'Ã—';
            this.topButton.classList.remove('primary');
            this.topButton.classList.add('close-btn');

            // Move mic/camera controls to top
            const bottomControls = document.getElementById('bottom-controls');
            bottomControls.classList.add('top-position');

            // Make controls always visible
            this.controlsOverlay.classList.add('always-visible');
          }
        }

        // Mic and camera toggles
        toggleMic() {
          this.micEnabled = !this.micEnabled;
          if (this.localStream) {
            this.localStream.getAudioTracks().forEach((track) => {
              track.enabled = this.micEnabled;
            });
          }
          this.micToggle.textContent = this.micEnabled ? 'ðŸŽ¤' : 'ðŸ”‡';
          this.micToggle.classList.toggle('off', !this.micEnabled);
        }

        toggleCamera() {
          this.cameraEnabled = !this.cameraEnabled;
          if (this.localStream) {
            this.localStream.getVideoTracks().forEach((track) => {
              track.enabled = this.cameraEnabled;
            });
          }
          this.cameraToggle.textContent = this.cameraEnabled ? 'ðŸ“¹' : 'ðŸš«';
          this.cameraToggle.classList.toggle('off', !this.cameraEnabled);
        }

        // Controls are always visible - no hiding functionality

        showToast(message) {
          this.toast.textContent = message;
          this.toast.classList.add('show');
          setTimeout(() => {
            this.toast.classList.remove('show');
          }, 2000);
        }

        closeConnection() {
          location.reload();
        }

        async createDataConnection() {
          this.pc = new RTCPeerConnection({
            iceServers: this.iceServers,
            iceCandidatePoolSize: 10,
          });

          this.pc.oniceconnectionstatechange = () => {
            console.log('ICE:', this.pc.iceConnectionState);
          };

          if (this.role === 'initiator') {
            this.dataChannel = this.pc.createDataChannel('media', {
              ordered: true,
            });
            this.setupDataChannel(this.dataChannel);
          }

          this.pc.ondatachannel = (event) => {
            this.dataChannel = event.channel;
            this.setupDataChannel(this.dataChannel);
          };

          this.pc.onconnectionstatechange = () => {
            console.log('PC:', this.pc.connectionState);
            if (
              this.pc.connectionState === 'connected' &&
              !this.connectionEstablished
            ) {
              this.connectionEstablished = true;
              setTimeout(() => this.startMediaNegotiation(), 500);
            }
          };
        }

        setupDataChannel(channel) {
          channel.onopen = () => {
            console.log('DataChannel opened');
            this.connectionEstablished = true;
          };

          channel.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'media-offer') {
              await this.handleMediaOffer(data);
            } else if (data.type === 'media-answer') {
              await this.handleMediaAnswer(data);
            }
          };
        }

        async generateOffer() {
          const offer = await this.pc.createOffer();
          await this.pc.setLocalDescription(offer);
          await this.waitForICE();

          const offerData = {
            type: 'offer',
            sdp: this.pc.localDescription.sdp,
          };

          const encoded = btoa(JSON.stringify(offerData));
          const url = `${window.location.origin}${window.location.pathname}#${encoded}`;

          this.topButton.dataset.offerUrl = url;
          this.showToast('Offer ready to share');
        }

        async handleOffer() {
          try {
            const data = JSON.parse(atob(location.hash.slice(1)));

            if (data.type !== 'offer') return;

            this.role = 'responder';
            this.remoteVideo.classList.add('hidden');
            this.setButtonState('share');

            await this.createDataConnection();

            await this.pc.setRemoteDescription({
              type: 'offer',
              sdp: data.sdp,
            });

            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);
            await this.waitForICE();

            const answerData = {
              type: 'answer',
              sdp: this.pc.localDescription.sdp,
            };

            const encoded = btoa(JSON.stringify(answerData));

            // Store answer code for share button
            this.topButton.dataset.answerCode = encoded;
            this.topButton.textContent = 'Share Answer Code';
            this.topButton.onclick = async () => {
              await this.shareAnswerCode(encoded);
            };

            this.showToast('Answer code ready to share');
          } catch (err) {
            console.error('Handle offer error:', err);
            this.showToast('âŒ Error processing offer');
          }
        }

        async processAnswer() {
          const input = this.answerInput.value.trim();
          if (!input) return;

          try {
            const data = JSON.parse(atob(input));

            if (data.type !== 'answer') {
              this.showToast('âŒ Invalid answer code');
              return;
            }

            this.pasteModal.classList.add('hidden');
            this.showToast('â³ Connecting...');

            await this.pc.setRemoteDescription({
              type: 'answer',
              sdp: data.sdp,
            });

            this.answerInput.value = '';
          } catch (err) {
            console.error('Process answer error:', err);
            this.showToast('âŒ Invalid answer code');
          }
        }

        async startMediaNegotiation() {
          console.log('Starting media negotiation, role:', this.role);

          if (this.role === 'initiator') {
            await this.sendMediaOffer();
          }
        }

        async sendMediaOffer() {
          this.mediaPc = new RTCPeerConnection({
            iceServers: this.iceServers,
            iceCandidatePoolSize: 10,
          });

          if (this.localStream) {
            this.localStream.getTracks().forEach((track) => {
              this.mediaPc.addTrack(track, this.localStream);
            });
          }

          this.mediaPc.ontrack = (event) => {
            this.showConnectedState(event.streams[0]);
          };

          const offer = await this.mediaPc.createOffer();
          await this.mediaPc.setLocalDescription(offer);
          await this.waitForICE(this.mediaPc);

          const mediaOffer = {
            type: 'media-offer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          this.dataChannel.send(JSON.stringify(mediaOffer));
        }

        async handleMediaOffer(data) {
          this.mediaPc = new RTCPeerConnection({
            iceServers: this.iceServers,
            iceCandidatePoolSize: 10,
          });

          if (this.localStream) {
            this.localStream.getTracks().forEach((track) => {
              this.mediaPc.addTrack(track, this.localStream);
            });
          }

          this.mediaPc.ontrack = (event) => {
            this.showConnectedState(event.streams[0]);
          };

          await this.mediaPc.setRemoteDescription({
            type: 'offer',
            sdp: data.sdp,
          });

          const answer = await this.mediaPc.createAnswer();
          await this.mediaPc.setLocalDescription(answer);
          await this.waitForICE(this.mediaPc);

          const mediaAnswer = {
            type: 'media-answer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          this.dataChannel.send(JSON.stringify(mediaAnswer));
        }

        async handleMediaAnswer(data) {
          await this.mediaPc.setRemoteDescription({
            type: 'answer',
            sdp: data.sdp,
          });
        }

        showConnectedState(remoteStream) {
          this.remoteVideo.srcObject = remoteStream;
          this.remoteVideo.classList.remove('hidden');
          this.connectionEstablished = true;

          this.setButtonState('close');
          this.showToast('ðŸŽ‰ Connected!');
          this.updateVideoLayout();

          // Controls stay visible - no auto-hide
        }

        waitForICE(pc = this.pc) {
          return new Promise((resolve) => {
            if (pc.iceGatheringState === 'complete') {
              resolve();
              return;
            }

            const onStateChange = () => {
              if (pc.iceGatheringState === 'complete') {
                pc.removeEventListener(
                  'icegatheringstatechange',
                  onStateChange
                );
                resolve();
              }
            };

            pc.addEventListener('icegatheringstatechange', onStateChange);
            setTimeout(resolve, 3000);
          });
        }
      }

      const rtc = new P2PWebRTC();
      window.addEventListener('load', () => rtc.init());
    </script>
  </body>
</html>
