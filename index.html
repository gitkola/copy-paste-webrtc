<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Seamless WebRTC</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #0a0a0a;
        color: #fff;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .container {
        max-width: 700px;
        width: 100%;
        text-align: center;
      }

      .videos {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }

      video {
        width: 100%;
        height: 240px;
        background: #1a1a1a;
        border-radius: 12px;
        object-fit: cover;
        border: 2px solid transparent;
      }

      video.active {
        border-color: #00ff88;
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      }

      .placeholder {
        width: 100%;
        height: 240px;
        background: #1a1a1a;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        font-size: 16px;
        border: 2px dashed #333;
      }

      .status {
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 25px;
        font-size: 18px;
        font-weight: 500;
      }

      .share-box {
        background: linear-gradient(135deg, #2a2a2a, #1a3a2a);
        border-radius: 12px;
        padding: 30px;
        margin: 25px 0;
        border: 1px solid #333;
      }

      .share-link {
        background: #0a0a0a;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 15px;
        width: 100%;
        color: #fff;
        font-size: 13px;
        margin: 15px 0;
        word-break: break-all;
        font-family: 'SF Mono', Monaco, monospace;
        max-height: 120px;
        overflow-y: auto;
      }

      .copy-btn {
        padding: 12px 24px;
        background: linear-gradient(135deg, #00ff88, #00cc66);
        color: #000;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 600;
        transition: all 0.2s;
        margin: 10px;
      }

      .copy-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
      }

      .copy-btn.success {
        background: linear-gradient(135deg, #00cc66, #00aa44);
      }

      .timer {
        font-size: 16px;
        color: #ff6b6b;
        font-weight: 500;
        margin: 15px 0;
        opacity: 0.8;
      }

      .role {
        display: inline-block;
        padding: 6px 12px;
        background: rgba(0, 255, 136, 0.2);
        color: #00ff88;
        border-radius: 16px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        margin-bottom: 15px;
      }

      .hidden {
        display: none;
      }

      .stage-indicator {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
      }

      .stage {
        width: 8px;
        height: 8px;
        background: #333;
        border-radius: 50%;
        transition: all 0.3s;
      }

      .stage.active {
        background: #00ff88;
        transform: scale(1.5);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Initiator: Generate link -->
      <div id="initiatorState" class="hidden">
        <div class="role">Initiator</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage"></div>
          <div class="stage"></div>
        </div>
        <div class="status" id="initiatorStatus">
          Generating connection link...
        </div>
        <div class="share-box">
          <h3 style="margin-bottom: 15px">Share this link:</h3>
          <textarea class="share-link" id="initiatorLink" readonly></textarea>
          <button class="copy-btn" id="copyInitiatorBtn">üìã Copy Link</button>
          <div class="timer" id="initiatorTimer"></div>
        </div>
      </div>

      <!-- Responder: Generate response -->
      <div id="responderState" class="hidden">
        <div class="role">Responder</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage active"></div>
          <div class="stage"></div>
        </div>

        <div class="videos">
          <video
            id="responderVideo"
            autoplay
            muted
            playsinline
            class="active"
          ></video>
          <div class="placeholder">Waiting for connection...</div>
        </div>

        <div class="status" id="responderStatus">
          Send this link to complete connection:
        </div>
        <div class="share-box">
          <h3 style="margin-bottom: 15px">Response link:</h3>
          <textarea class="share-link" id="responderLink" readonly></textarea>
          <button class="copy-btn" id="copyResponderBtn">
            üìã Copy Response
          </button>
        </div>
      </div>

      <!-- Connecting state -->
      <div id="connectingState" class="hidden">
        <div class="role">Connecting</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage active"></div>
          <div class="stage active"></div>
        </div>

        <div class="videos">
          <video
            id="connectingLocalVideo"
            autoplay
            muted
            playsinline
            class="active"
          ></video>
          <div class="placeholder" id="connectingPlaceholder">
            Establishing connection...
          </div>
        </div>

        <div class="status" id="connectingStatus">
          ‚è≥ Connecting to video call...
        </div>
      </div>

      <!-- Final connection -->
      <div id="connectedState" class="hidden">
        <div class="role">Connected</div>
        <div class="stage-indicator">
          <div class="stage active"></div>
          <div class="stage active"></div>
          <div class="stage active"></div>
        </div>

        <div class="videos">
          <video
            id="localVideo"
            autoplay
            muted
            playsinline
            class="active"
          ></video>
          <video id="remoteVideo" autoplay playsinline class="active"></video>
        </div>

        <div class="status" id="connectedStatus">üéâ Video call connected!</div>
      </div>

      <!-- Initial state (fallback) -->
      <div id="initialState">
        <div class="status">Open a connection link to start</div>
      </div>
    </div>

    <script>
      class SeamlessWebRTC {
        constructor() {
          this.pc = null;
          this.dataChannel = null;
          this.mediaPc = null;
          this.localStream = null;
          this.role = null;
          this.timer = null;
          this.connectionEstablished = false;
          this.mediaConnectionReady = false;
        }

        async init() {
          // Auto-detect role and start flow
          if (location.hash) {
            await this.handleIncomingData();
          } else {
            await this.startAsInitiator();
          }
        }

        async startAsInitiator() {
          this.role = 'initiator';
          this.showState('initiatorState');
          this.updateStatus('initiatorStatus', 'Generating connection link...');

          await this.createDataOnlyConnection();
          await this.generateInitiatorLink();
          this.startTimer();
        }

        async createDataOnlyConnection() {
          this.pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
            ],
          });

          // Create data channel for media negotiation
          if (this.role === 'initiator' || !this.dataChannel) {
            this.dataChannel = this.pc.createDataChannel('media', {
              ordered: true,
            });

            this.setupDataChannel(this.dataChannel);
          }

          this.pc.ondatachannel = (event) => {
            this.dataChannel = event.channel;
            this.setupDataChannel(this.dataChannel);
          };

          this.pc.onconnectionstatechange = () => {
            console.log('PC state:', this.pc.connectionState);
            if (
              this.pc.connectionState === 'connected' &&
              !this.connectionEstablished
            ) {
              this.connectionEstablished = true;
              setTimeout(() => this.startMediaNegotiation(), 500);
            }
          };
        }

        setupDataChannel(channel) {
          channel.onopen = () => {
            console.log('Data channel opened, role:', this.role);
            this.connectionEstablished = true;
          };

          channel.onmessage = async (event) => {
            console.log('Data channel message:', event.data.substring(0, 50));
            const data = JSON.parse(event.data);
            if (data.type === 'media-offer') {
              await this.handleMediaOffer(data);
            } else if (data.type === 'media-answer') {
              await this.handleMediaAnswer(data);
            }
          };
        }

        async generateInitiatorLink() {
          const offer = await this.pc.createOffer();
          await this.pc.setLocalDescription(offer);
          await this.waitForICE();

          const linkData = {
            type: 'data-offer',
            sdp: this.pc.localDescription.sdp,
            timestamp: Date.now(),
          };

          const encoded = btoa(JSON.stringify(linkData));
          const shareUrl = `${window.location.origin}${window.location.pathname}#${encoded}`;

          document.getElementById('initiatorLink').value = shareUrl;
          this.updateStatus(
            'initiatorStatus',
            'üì§ Share the link above to start connection'
          );
        }

        async handleIncomingData() {
          try {
            const data = JSON.parse(atob(location.hash.slice(1)));

            if (data.type === 'data-offer') {
              await this.handleDataOffer(data);
            } else if (data.type === 'data-answer') {
              await this.handleDataAnswer(data);
            }
          } catch (err) {
            console.error('Invalid link data:', err);
            this.showState('initialState');
          }
        }

        async handleDataOffer(offerData) {
          this.role = 'responder';
          this.showState('responderState');
          this.updateStatus('responderStatus', 'Generating response...');

          // Setup camera for responder
          await this.setupCamera('responderVideo');

          await this.createDataOnlyConnection();

          await this.pc.setRemoteDescription({
            type: 'offer',
            sdp: offerData.sdp,
          });

          const answer = await this.pc.createAnswer();
          await this.pc.setLocalDescription(answer);
          await this.waitForICE();

          const responseData = {
            type: 'data-answer',
            sdp: this.pc.localDescription.sdp,
            timestamp: Date.now(),
          };

          const encoded = btoa(JSON.stringify(responseData));
          const responseUrl = `${window.location.origin}${window.location.pathname}#${encoded}`;

          document.getElementById('responderLink').value = responseUrl;
          this.updateStatus(
            'responderStatus',
            'üì§ Send response link to complete connection'
          );
        }

        async handleDataAnswer(answerData) {
          console.log('Handling data answer');

          // Show connecting state
          this.showState('connectingState');
          this.updateStatus(
            'connectingStatus',
            '‚è≥ Establishing data connection...'
          );

          // Setup camera
          await this.setupCamera('connectingLocalVideo');

          // If we don't have PC yet, create it
          if (!this.pc) {
            this.role = 'initiator';
            await this.createDataOnlyConnection();

            // Recreate offer
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);
            await this.waitForICE();
          }

          await this.pc.setRemoteDescription({
            type: 'answer',
            sdp: answerData.sdp,
          });

          this.updateStatus(
            'connectingStatus',
            '‚è≥ Data channel connecting...'
          );
          this.clearTimer();
        }

        async startMediaNegotiation() {
          console.log('Starting media negotiation, role:', this.role);

          if (this.role === 'initiator') {
            this.updateStatus(
              'connectingStatus',
              'üìπ Setting up video connection...'
            );
            await this.sendMediaOffer();
          } else {
            this.updateStatus(
              'responderStatus',
              'üìπ Waiting for video connection...'
            );
          }
        }

        async setupCamera(videoId) {
          try {
            this.localStream = await navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 480 },
              audio: true,
            });

            if (videoId) {
              const videoEl = document.getElementById(videoId);
              if (videoEl) {
                videoEl.srcObject = this.localStream;
              }
            }
          } catch (err) {
            console.error('Camera error:', err);
          }
        }

        async sendMediaOffer() {
          console.log('Sending media offer');

          // Create new peer connection for media
          this.mediaPc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
            ],
          });

          // Add local stream
          if (this.localStream) {
            this.localStream.getTracks().forEach((track) => {
              this.mediaPc.addTrack(track, this.localStream);
            });
          }

          this.mediaPc.ontrack = (event) => {
            console.log('Received remote track');
            this.showConnectedState(event.streams[0]);
          };

          const offer = await this.mediaPc.createOffer();
          await this.mediaPc.setLocalDescription(offer);
          await this.waitForICE(this.mediaPc);

          const mediaOffer = {
            type: 'media-offer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          console.log('Sending via data channel');
          this.dataChannel.send(JSON.stringify(mediaOffer));
        }

        async handleMediaOffer(data) {
          console.log('Handling media offer');

          // Create media peer connection for responder
          this.mediaPc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
            ],
          });

          // Add local stream
          if (this.localStream) {
            this.localStream.getTracks().forEach((track) => {
              this.mediaPc.addTrack(track, this.localStream);
            });
          }

          this.mediaPc.ontrack = (event) => {
            console.log('Responder received remote track');
            this.showConnectedState(event.streams[0]);
          };

          await this.mediaPc.setRemoteDescription({
            type: 'offer',
            sdp: data.sdp,
          });

          const answer = await this.mediaPc.createAnswer();
          await this.mediaPc.setLocalDescription(answer);
          await this.waitForICE(this.mediaPc);

          const mediaAnswer = {
            type: 'media-answer',
            sdp: this.mediaPc.localDescription.sdp,
          };

          console.log('Sending media answer');
          this.dataChannel.send(JSON.stringify(mediaAnswer));
        }

        async handleMediaAnswer(data) {
          console.log('Handling media answer');

          await this.mediaPc.setRemoteDescription({
            type: 'answer',
            sdp: data.sdp,
          });
        }

        showConnectedState(remoteStream) {
          console.log('Showing connected state');
          this.showState('connectedState');

          // Set local video
          const localVideo = document.getElementById('localVideo');
          if (this.localStream) {
            localVideo.srcObject = this.localStream;
          }

          // Set remote video
          const remoteVideo = document.getElementById('remoteVideo');
          remoteVideo.srcObject = remoteStream;

          this.updateStatus('connectedStatus', 'üéâ Video call connected!');
        }

        waitForICE(pc = this.pc) {
          return new Promise((resolve) => {
            if (pc.iceGatheringState === 'complete') {
              resolve();
              return;
            }

            const onStateChange = () => {
              if (pc.iceGatheringState === 'complete') {
                pc.removeEventListener(
                  'icegatheringstatechange',
                  onStateChange
                );
                resolve();
              }
            };

            pc.addEventListener('icegatheringstatechange', onStateChange);
            setTimeout(resolve, 2000);
          });
        }

        showState(stateId) {
          document.querySelectorAll('.container > div').forEach((el) => {
            el.classList.add('hidden');
          });
          document.getElementById(stateId).classList.remove('hidden');
        }

        updateStatus(elementId, message) {
          const el = document.getElementById(elementId);
          if (el) el.textContent = message;
        }

        startTimer() {
          let remaining = 120; // 2 minutes
          const timerEl = document.getElementById('initiatorTimer');

          const tick = () => {
            const minutes = Math.floor(remaining / 60);
            const seconds = remaining % 60;
            timerEl.textContent = `Link expires in ${minutes}:${seconds
              .toString()
              .padStart(2, '0')}`;
            remaining--;

            if (remaining < 0) {
              this.clearTimer();
              timerEl.textContent = 'Link expired';
            }
          };

          tick();
          this.timer = setInterval(tick, 1000);
        }

        clearTimer() {
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
        }
      }

      const rtc = new SeamlessWebRTC();

      // Initialize on load
      window.addEventListener('load', () => {
        rtc.init();
      });

      // Copy button handlers
      document.getElementById('copyInitiatorBtn').onclick = function () {
        const link = document.getElementById('initiatorLink');
        navigator.clipboard.writeText(link.value);
        this.textContent = '‚úÖ Copied!';
        this.classList.add('success');
        setTimeout(() => {
          this.textContent = 'üìã Copy Link';
          this.classList.remove('success');
        }, 2000);
      };

      document.getElementById('copyResponderBtn').onclick = function () {
        const link = document.getElementById('responderLink');
        navigator.clipboard.writeText(link.value);
        this.textContent = '‚úÖ Copied!';
        this.classList.add('success');
        setTimeout(() => {
          this.textContent = 'üìã Copy Response';
          this.classList.remove('success');
        }, 2000);
      };
    </script>
  </body>
</html>
